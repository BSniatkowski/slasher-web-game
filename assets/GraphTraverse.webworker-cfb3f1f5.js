(function(){"use strict";const b=(o,s=[])=>{for(const c of s)if(o.id===c.id)return o;return o.previousNode?b(o.previousNode,s):!1},w=(o,s)=>Math.sqrt(Math.pow(o.x-s.x,2)+Math.pow(o.y-s.y,2)),D=({startPosition:o,startNodeId:s,destinationPosition:c,destinationNodeId:m,graph:h})=>{const p=h.find(({id:e})=>e===s),f=h.find(({id:e})=>e===m);if(!p||!f)return{path:[]};const v={...p,distance:w(f.center,p.center),neighborNodes:[],stepped:!0},y={...f,distance:0,neighborNodes:[]},u=[v,y];for(const e of h)e.id!==s&&e.id!==m&&u.push({...e,distance:w(y.center,e.center),neighborNodes:[]});for(const e of u)for(const t of e.neighborNodesIds){const n=u.find(({id:a})=>a===t);n&&e.neighborNodes.push(n)}const P=({distance:e},{distance:t})=>e-t,g=e=>{if(e.distance===0)return e;if(e.neighborNodes.filter(({stepped:t})=>!t).length===0&&e.previousNode)return g(e.previousNode);e.neighborNodes.sort(P);for(const t of e.neighborNodes)if(!t.stepped)return t.stepped=!0,t.previousNode=e,g(t)},N=g(v);if(!N)return{path:[]};const l=(e,t=[])=>e.previousNode?(t.push(e),l(e.previousNode,t)):t,r=l(N);for(let e=0;e<r.length;e++){const t=b(r[e],r[e].neighborNodes.filter(({id:n})=>{var a;return n!==((a=r[e].previousNode)==null?void 0:a.id)}));t&&(r[e].previousNode=t,e=r.findIndex(n=>n.id===t.id))}const M=l(N),i=[];for(const e of M)i.push({...e.center});return i[0]=c,i[i.length-1]={...o,z:0},i.reverse(),{path:i}},d={graph:null};onmessage=o=>{switch(o.data.type){case"init":{d.graph=o.data.graph;break}case"calculate":{if(!d.graph){postMessage({id:o.data.id,path:[o.data.startPosition,o.data.destinationPosition]});break}const{path:s}=D({graph:d.graph,...o.data});postMessage({id:o.data.id,path:s});break}default:console.warn(`There is no specified message type! Passed data: ${JSON.stringify(o.data)}`)}}})();
